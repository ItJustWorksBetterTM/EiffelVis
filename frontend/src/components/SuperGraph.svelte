<!-- svelte-ignore a11y-missing-attribute -->
<script lang="ts">
    import G6 from "@antv/g6";
    import { QueryStream, EiffelVisConnection } from "../eiffelvis";
    import { GraphSettings, StatefulLayout } from "../layout";
    import G6Graph from "./G6Graph.svelte";
    import { FullEvent, query_eq } from "../apidefinition";
    import { deep_copy } from "../utils";
    import config from "../config.json";
  
    import {
      empty_fixed_event_filters,
      FixedQuery,
      fixed_query_to_norm,
    } from "../uitypes";
    import { createEventDispatcher, onMount } from "svelte";
    import {backend_url, backend_has_ssl} from "../main"
    const dispatch = createEventDispatcher();
  
    const connection: EiffelVisConnection = new EiffelVisConnection(
      backend_url, backend_has_ssl
  )
  
    let graph_elem: G6Graph = null;
    let active_stream: QueryStream = null;
    let awaiting_query_request: boolean = false;
  
    let selected_node: FullEvent = null;
  
    let show_timebar: boolean = false;
    $: nonInteractiveState = true;
  
    let customTheme: Object = config.Theme.ColorBlind;
    let themeMap: Map<string, any> = new Map(Object.entries(customTheme));
    let legend: Map<string, any> = themeMap;
  
    let query_cache: { stream: QueryStream; query: FixedQuery }[] = [];
  
    export let qhistory: FixedQuery[] = [];
  
    let current_query: FixedQuery = {
      range_filter: { begin: { type: "Absolute", val: -500 }, end: null },
      event_filters: [empty_fixed_event_filters()],
      collection: { type: "Forward" },
    };
  
    $: current_query_changed =
      qhistory.length > 0 &&
      !query_eq(
        fixed_query_to_norm(current_query),
        fixed_query_to_norm(qhistory[qhistory.length - 1])
      );
  
    let graph_options: GraphSettings = {
      offset: 0,
      time_diff: 1000,
      y_scale: 0.99,
      x_sep: 60,
      y_sep: 60,
      hue: 360,
    };
  
    $: {
      if (graph_elem) {
        // TODO: split up?
        graph_elem.resizeGraph();
        selected_node = null;
        submit_state_query();
      }
    }
  
    // non-interactive mode variables
    let show_message: boolean = false;
    let dayToDisplay: string = null;
    let dayLastEventRecieved: number = 0;
    let recievedNewNode: boolean = false;
    let displayTime: string = null;
    let displayDate: string = null;
  
  const displayInfoMessage= () =>{ //After 1 minute of no nodes recieved, a message is displayed. 

      let time: Date = new Date();
      if ( time.getDate() == dayLastEventRecieved){
          dayToDisplay = "TODAY";     
      }
      else if (time.getDate() - dayLastEventRecieved == 1){   
          dayToDisplay = "YESTERDAY"; 
      }
      else if (time.getDate() - dayLastEventRecieved> 1){
          dayToDisplay = displayDate;
      }
      if (recievedNewNode==false && dayToDisplay != null  ){
        show_message = true; 
        nonInteractiveState = false;
        console.log("received no new node")
      }
      else {
        show_message = false;
      } 
}
 let ms = 60000;
 let interval= setInterval( displayInfoMessage, ms); // set timer to run every 1 minute
 // timer function to wait 1 minute to check if nodes are still being received, 
 // if no new nodes after 1 minute, message for latest node received is displayed
 const resetTimer = () =>{
  clearInterval(interval); // interval is reset every minute 
  interval= setInterval( displayInfoMessage, ms);
}

  
export let consume_query = async () => {
    const layout = new StatefulLayout();
    awaiting_query_request = true;
    const iter = await active_stream.iter();
    awaiting_query_request = false;
    graph_elem.reset();
    let once = true;
    for await (const event of iter) {
      layout.apply(event, graph_options);
      graph_elem.push(event);
      graph_elem.nonInteractiveMode(event,nonInteractiveState);
    
      //every time a node is pushed to the graph the variables are updated
      let timeJson: number = event.time;
      let time: Date = new Date(timeJson);
      dayLastEventRecieved = time.getDate(); 
      displayDate= time.toLocaleDateString([], {weekday: "short", day: "numeric", month: "short",year: "numeric"});
      displayTime= time.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})
      recievedNewNode = true;
      show_message = false; 
       
      // TODO: Find a better way to do this
      if (once) {
        graph_elem.focusNode(event.id);
        once = false;
      }
      legend = layout.getNodeStyle();
    }
    recievedNewNode = false; 
    console.log("stoped recieving nodes")
    resetTimer();// method to reset timer
    
  };
    const submit_state_query = () => submit_query(current_query);
  
    export const submit_query = (fquery: FixedQuery) => {
      const new_query = fixed_query_to_norm(fquery);
      active_stream = (() => {
        const cached = query_cache.find((v) =>
          query_eq(new_query, fixed_query_to_norm(v.query))
        );
        if (cached) {
          return cached.stream;
        } else {
          const ret = new QueryStream(connection, deep_copy(new_query));
          query_cache = [
            ...query_cache,
            { stream: ret, query: deep_copy(fquery) },
          ];
          return ret;
        }
      })();
  
      consume_query();
      qhistory = [...qhistory, deep_copy(fquery)];
      show_timebar = false;
      graph_elem.updateTimeBar(show_timebar);
    };
  
    //const add_filter = () => {};
  
    // TODO: add loading for this
    const on_node_selected = async (e: any) => {
      if (e.detail?.target) {
        selected_node = await connection.fetch_node(
          e.detail.target._cfg.model.id
        );
        dispatch("selected_node_change", selected_node);
      } else {
        selected_node = null;
      }
    };
  
    export const use_selected_as_root = () => {
        current_query.collection = { type: "AsRoots" };
        current_query.range_filter = { begin: null, end: null };
    
        const filters = empty_fixed_event_filters();
        filters.ids.pred.ids = [selected_node.meta.id];
        current_query.event_filters = [filters];
    
        submit_state_query();
      }; 
  
    export const reset_graph_options = () => {
        graph_options = {
          offset: 0,
          time_diff: 1000,
          y_scale: 0.99,
          x_sep: 60,
          y_sep: 60,
          hue: 360,
        };
        consume_query();
      }; 
  
    const options = {
      width: 400,
      height: 400,
      workerEnabled: false,
      fitView: true,
      fitViewPadding: [0, 0, 0, 600],
      groupByTypes: false, // enables to control z-index of items https://antv-g6.gitee.io/en/docs/manual/middle/elements/methods/elementIndex
      defaultEdge: {
        labelCfg: {
          position: "center",
          style: {
            // default styling for the edge labels should come here https://g6.antv.vision/en/docs/manual/middle/elements/edges/defaultEdge
            fontSize: 10,
            fill: "#ffffff",
            fillOpacity: 0,
            shadowColor: "#151517",
            shadowOffsetY: 10,
            shoadowOffsetX: 10,
            shadowBlur: 10,
          },
        },
        style: {
          // default styling for the edge should come here
          lineWidth: 1,
          opacity: 0.15,
          fill: "#fff",
          position: "middle",
          endArrow: { path: G6.Arrow.triangle(5, 10, 0), d: 0 },
        },
      },
      modes: {
        default: [
          "click-select",
          "drag-canvas",
          {
            type: "zoom-canvas",
            enableOptimize: true,
          },
        ],
      },
    };
    const paneClicked = () => {
      dispatch("pane_clicked", graph_elem);
    };

    export const getQhistory = () => {
      return this.qhistory
    };

    onMount(async () => {
      dispatch("set_graph_element", graph_elem);
    });
  </script>
  
  <div on:click={paneClicked}>
    <div
        style="white-space: nowrap;"      
              class:hidden={!show_message}
              class:show= {show_message}
              >
      <span class="text-sm text-left w-full h-full">LATEST EVENTS RECEIVED - {dayToDisplay} AT {displayTime}</span> 
    </div> 
    <G6Graph
      on:nodeselected={on_node_selected}
      bind:this={graph_elem}
      bind:nonInteractiveState
      {options}
      data={{}}
    />
  </div>
  <style lang="postcss" global>
      @tailwind base;
    @tailwind components;
    @tailwind utilities;
  </style>
  